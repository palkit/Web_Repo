‚úÖ 1. Single-thread vs Multi-thread
Single-threaded: JS executes one task at a time (main thread).

Multi-threaded: True parallel execution using Web Workers (in browsers).

üîπ Web Workers:
Run JS in background thread, avoids UI freezing.
Used for:

CPU-heavy tasks (loops, image processing, parsing)

‚úÖ 2. Async in JS (Promises, async/await, setTimeout)
Used to handle non-blocking tasks:

Network requests

Background timers

Large calculations (if with Web Worker)

File reading/parsing (CSV/JSON)

‚úÖ 3. What is a Thread?
A thread is a path of execution.

JS uses one main thread.

Web Workers create extra threads for heavy tasks.

‚úÖ 4. Horizontal vs Vertical Scaling
Type	Meaning
Vertical	Upgrade one server's CPU/RAM
Horizontal	Add more servers (Node.js: clustering, PM2, load balancing)

‚úÖ 5. Latency vs Throughput
Term	Meaning
Latency	Time to handle one request
Throughput	Total requests handled per second

‚úÖ 6. JS: Compiled or Interpreted?
Originally interpreted

Now uses JIT (Just-In-Time) compilation via engines like V8

‚úÖ 7. JS: Sync or Async?
JS is synchronous by default

Becomes asynchronous using:

setTimeout, fetch, Promise, async/await

Managed by the Event Loop

üîÅ Difference: Sync vs Async vs Multithreading
Concept	Parallel?	Blocking?	JS Example
Synchronous	‚ùå No	‚úÖ Yes	Regular code
Asynchronous	‚úÖ Looks like	‚ùå No	setTimeout, fetch
Multithreading	‚úÖ Yes	‚ùå Depends	Web Workers

üîπ JavaScript Hoisting
Hoisting: JS moves declarations to top of scope.

Only works for:

var (value = undefined)

Function declarations

üîπ Temporal Dead Zone (TDZ)
Applies to let and const

Accessing before initialization = ‚ùå ReferenceError

js
Copy
Edit
console.log(x); // ‚ùå
let x = 10;
üîπ Arrow Functions
Shorter syntax using =>

No own this, arguments, or super

Lexically bound this

js
Copy
Edit
const add = (a, b) => a + b;
Feature	Arrow Function	Regular Function
this	Lexical (outer)	Dynamic (depends)
Hoisting	‚ùå Not hoisted	‚úÖ Hoisted
Syntax	Concise	Traditional

üîπ Function Expression
A function assigned to a variable

Not hoisted like declarations

Can be anonymous or named

js
Copy
Edit
const greet = function(name) {
  return `Hello, ${name}`;
};
üîπ Anonymous Functions
Functions with no name

Common in callbacks, IIFEs

js
Copy
Edit
setTimeout(function() {
  console.log("Hello");
}, 1000);
‚úÖ Summary Table
Concept	Description	Hoisted?
Hoisting	Moves declarations (not initializations)	‚úÖ var, fn
TDZ	Accessing let/const before init ‚Üí error	‚ùå Error
Arrow Function	Short, no this/arguments	‚ùå Not hoisted
Anonymous Func	Used in expressions/callbacks	‚ùå Depends
Function Expr	Function assigned to a variable	‚ùå Not hoisted

üîÑ this Behavior Examples
js
Copy
Edit
function show() {
  console.log(this); // Global (window in browser)
}

const user = {
  name: "Palkit",
  sayHi() {
    console.log(this.name); // "Palkit"
  }
};

const user2 = {
  name: "Ravi",
  greet: () => {
    console.log(this.name); // undefined (arrow uses outer `this`)
  }
};

function greet() {
  console.log(this.name);
}
const person = { name: "Neha" };
greet.call(person); // "Neha"




Final Closure Recap
Closure is:
‚û§ Function + Its outer scope (preserved in Heap)

Why Closure works:
‚û§ Because inner function still has reference to outer variable, JavaScript's engine keeps it in memory (heap)

JavaScript Engine handles:
‚û§ Stack for execution
‚û§ Heap for variable/closure storage
‚û§ Garbage Collection to remove unused variables

üëá Ask Yourself These to Spot Closure:
‚ùì Question	‚úÖ If Yes...
Is function returned from another function?	‚û§ Closure!
Is function using variable from parent?	‚û§ Closure!
Is that parent function already done?	‚û§ Closure!
